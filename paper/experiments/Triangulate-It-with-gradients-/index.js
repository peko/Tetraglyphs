// Generated by CoffeeScript 1.4.0
(function() {
  var S3, TR, Ta, Tr, alpha, b2c, c2b, clear, getTriangle, getTriangles, makeTriangle, mouseDown, mouseUp, onMouseOver, onResize, point2color, point2hex, pointToTriangle, resize, resizeTimeout, toggleAlpha, toggleStroke, triangle2gradient, triangles;

  TR = 1.0;

  Tr = TR / 2.0;

  S3 = Math.sqrt(3.0);

  Ta = TR * S3;

  window.strokeN = "#DDF";

  window.strokeO = "#888";

  window.stroked = true;

  triangles = {};

  clear = function() {
    console.log("clear");
    return ctx.clearRect(0, 0, cvs.width, cvs.height);
  };

  resizeTimeout = -1;

  resize = function() {
    console.log("resize");
    this.W = cvs.width = 4096;
    this.H = cvs.height = 4096;
    this.ctx = cvs.getContext("2d");
    clear();
    if (img.src === "") {
      return ctx.fillText("Drop an image onto the canvas", 10, 20);
    } else {
      return ctx.drawImage(img, 0, 0);
    }
  };

  onResize = function() {
    clearTimeout(resizeTimeout);
    return setTimeout(resize, 500);
  };

  this.cvs = $("canvas")[0];

  this.img = document.createElement("img");

  resize();

  window.rph = new Raphael(document.getElementById('cont'), W, H);

  this.bg = rph.rect(0, 0, W, H);

  bg.attr("fill", "rgba(0,0,0,0)");

  img.addEventListener("load", (function() {
    clear();
    return ctx.drawImage(img, 0, 0);
  }), false);

  window.addEventListener("dragover", (function(evt) {
    return evt.preventDefault();
  }), false);

  window.addEventListener("drop", (function(evt) {
    var file, files, reader;
    files = evt.dataTransfer.files;
    if (files.length > 0) {
      file = files[0];
      if (typeof FileReader !== "undefined" && file.type.indexOf("image") !== -1) {
        reader = new FileReader();
        reader.onload = function(evt) {
          return img.src = evt.target.result;
        };
        reader.readAsDataURL(file);
      }
    }
    return evt.preventDefault();
  }), false);

  c2b = function(p, a, b, c) {
    var ac, bc, d, pc, u, v, w;
    ac = {
      x: a.x - c.x,
      y: a.y - c.y
    };
    bc = {
      x: b.x - c.x,
      y: b.y - c.y
    };
    pc = {
      x: p.x - c.x,
      y: p.y - c.y
    };
    d = bc.y * ac.x - bc.x * ac.y;
    u = (bc.y * pc.x - bc.x * pc.y) / d;
    v = (ac.x * pc.y - ac.y * pc.x) / d;
    w = 1 - u - v;
    return {
      u: u,
      v: v,
      w: w
    };
  };

  b2c = function(u, v, a, b, c) {
    var w;
    w = 1 - u - v;
    return {
      x: a.x * u + b.x * v + c.x * w,
      y: a.y * u + b.y * v + c.y * w
    };
  };

  getTriangles = function(z, p, a, b, c, T, H) {
    var ab, bc, br, ca;
    if (T == null) {
      T = null;
    }
    if (H == null) {
      H = null;
    }
    z = z >> 1;
    if (z === 0) {
      return T;
    }
    br = c2b(p, a, b, c);
    if (br.u > 0 && br.v > 0 && br.w > 0) {
      if (T == null) {
        T = {};
      }
      if (H == null) {
        H = 0x4;
      }
      T[H] = [a, b, c];
      ab = {
        x: (a.x + b.x) / 2,
        y: (a.y + b.y) / 2
      };
      bc = {
        x: (b.x + c.x) / 2,
        y: (b.y + c.y) / 2
      };
      ca = {
        x: (c.x + a.x) / 2,
        y: (c.y + a.y) / 2
      };
      if (br.u <= 1 / 2 && br.v <= 1 / 2 && br.w <= 1 / 2) {
        this.getTriangles(z, p, ab, bc, ca, T, H << 2 | 0x0);
      }
      if (br.u > 1 / 2) {
        this.getTriangles(z, p, a, ab, ca, T, H << 2 | 0x1);
      }
      if (br.v > 1 / 2) {
        this.getTriangles(z, p, ab, b, bc, T, H << 2 | 0x2);
      }
      if (br.w > 1 / 2) {
        this.getTriangles(z, p, ca, bc, c, T, H << 2 | 0x3);
      }
    }
    return T;
  };

  getTriangle = function(p, a, b, c) {
    var T, br, cor, d, inc, u, v, w;
    br = c2b(p, a, b, c);
    u = Math.floor(br.u);
    v = Math.floor(br.v);
    w = Math.floor(br.w);
    d = (u + v + w) % 2;
    inc = !d ? 1 / 3 : 2 / 3;
    cor = b2c(u + inc, v + inc, a, b, c);
    T = !d ? [
      {
        x: cor.x + a.x,
        y: cor.y + a.y
      }, {
        x: cor.x + b.x,
        y: cor.y + b.y
      }, {
        x: cor.x + c.x,
        y: cor.y + c.y
      }
    ] : [
      {
        x: cor.x + a.x,
        y: cor.y - a.y
      }, {
        x: cor.x - b.x,
        y: cor.y - b.y
      }, {
        x: cor.x - c.x,
        y: cor.y - c.y
      }
    ];
    T.push({
      u: u + inc,
      v: v + inc,
      w: 1 - u - v - inc * 2
    });
    return T;
  };

  point2color = function(p) {
    var b, c, g, r;
    c = ctx.getImageData(p.x, p.y, 1, 1).data;
    r = c[0];
    g = c[1];
    b = c[2];
    console.log(r, g, b);
    return "rgba(" + r + "," + g + "," + b + ",1.0)";
  };

  point2hex = function(p) {
    var b, c, g, r;
    c = ctx.getImageData(p.x, p.y, 1, 1).data;
    r = c[0] << 16;
    g = c[1] << 8;
    b = c[2];
    c = "" + ((r | g | b).toString(16));
    if (c.length === 1) {
      c = "00" + c;
    }
    if (c.length === 5) {
      c = "0" + c;
    }
    return "#" + c;
  };

  triangle2gradient = function(a, b, c) {
    var angle, b1, b2, c0, c1, c2, c3, cl1, cl2, cx, cy, g1, g2, gradient, r1, r2;
    cx = (a.x + b.x + c.x) / 3.0 | 0;
    cy = (a.y + b.y + c.y) / 3.0 | 0;
    c0 = ctx.getImageData(cx, cy, 1, 1).data;
    c1 = ctx.getImageData(a.x, a.y, 1, 1).data;
    c2 = ctx.getImageData(b.x, b.y, 1, 1).data;
    c3 = ctx.getImageData(c.x, c.y, 1, 1).data;
    r1 = c0[0] / 2 + (c1[0] + c2[0] + c3[0]) / 6;
    g1 = c0[1] / 2 + (c1[1] + c2[1] + c3[1]) / 6;
    b1 = c0[2] / 2 + (c1[2] + c2[2] + c3[2]) / 6;
    r2 = (c0[0] + c1[0] + c2[0] + c3[0]) / 4.25;
    g2 = (c0[1] + c1[1] + c2[1] + c3[1]) / 4.25;
    b2 = (c0[2] + c1[2] + c2[2] + c3[2]) / 4.25;
    cl1 = "#" + (((1 << 24) + (r1 << 16) + (g1 << 8) + (b1 << 0)).toString(16).slice(1));
    cl2 = "#" + (((1 << 24) + (r2 << 16) + (g2 << 8) + (b2 << 0)).toString(16).slice(1));
    angle = (Math.random() * 12 | 0) * 30;
    gradient = "" + angle + "-" + cl1 + ":5-" + cl2 + ":95";
    console.log(gradient);
    return gradient;
  };

  onMouseOver = function(e) {
    var d, p0, p1, p2, p3, p4, p5;
    if (!window.startSplit) {
      return;
    }
    d = this["data"];
    if (d.n) {
      return;
    }
    this.remove();
    p0 = b2c(1, 0, d.a, d.b, d.c);
    p1 = b2c(1 / 2, 1 / 2, d.a, d.b, d.c);
    p2 = b2c(0, 1, d.a, d.b, d.c);
    p3 = b2c(0, 1 / 2, d.a, d.b, d.c);
    p4 = b2c(0, 0, d.a, d.b, d.c);
    p5 = b2c(1 / 2, 0, d.a, d.b, d.c);
    makeTriangle(p0, p1, p5);
    makeTriangle(p1, p2, p3);
    makeTriangle(p3, p4, p5);
    return makeTriangle(p1, p3, p5);
  };

  mouseDown = function(e) {
    var d, p0, p1, p2, p3, p4, p5;
    window.startSplit = true;
    window.newTriangles = [];
    d = this["data"];
    this.remove();
    p0 = b2c(1, 0, d.a, d.b, d.c);
    p1 = b2c(1 / 2, 1 / 2, d.a, d.b, d.c);
    p2 = b2c(0, 1, d.a, d.b, d.c);
    p3 = b2c(0, 1 / 2, d.a, d.b, d.c);
    p4 = b2c(0, 0, d.a, d.b, d.c);
    p5 = b2c(1 / 2, 0, d.a, d.b, d.c);
    makeTriangle(p0, p1, p5);
    makeTriangle(p1, p2, p3);
    makeTriangle(p3, p4, p5);
    return makeTriangle(p1, p3, p5);
  };

  mouseUp = function(e) {
    var t, _i, _len, _ref, _results;
    window.startSplit = false;
    _ref = window.newTriangles;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      t["data"].n = 0;
      if (window.stroked) {
        t.attr("stroke", window.strokeO);
      } else {
        t.attr("stroke", "none");
      }
      _results.push(window.newTriangles = []);
    }
    return _results;
  };

  makeTriangle = function(a, b, c) {
    var cl1, cl2, cx, cy, tr, _ref;
    tr = rph.path("M" + a.x + " " + a.y + "L" + b.x + " " + b.y + "L" + c.x + " " + c.y + "L" + a.x + " " + a.y);
    cx = (a.x + b.x + c.x) / 3.0 | 0;
    cy = (a.y + b.y + c.y) / 3.0 | 0;
    cl1 = point2hex({
      x: a.x,
      y: a.y
    });
    cl2 = point2hex({
      x: b.x,
      y: b.y
    });
    tr.attr("fill", triangle2gradient(a, b, c));
    tr.attr("stroke", window.strokeN);
    tr["data"] = {
      cx: cx,
      cy: cy,
      a: a,
      b: b,
      c: c,
      n: 1
    };
    tr.mousedown(mouseDown);
    tr.mouseup(mouseUp);
    tr.mouseover(onMouseOver);
    if ((_ref = window.newTriangles) == null) {
      window.newTriangles = [];
    }
    window.newTriangles.push(tr);
    return tr;
  };

  pointToTriangle = function(x, y, l) {
    var a, b, c, t, tr, z;
    if (l == null) {
      l = 9;
    }
    z = Math.pow(2, l);
    a = {
      x: 0,
      y: TR * z
    };
    b = {
      x: Ta / 2 * z,
      y: -Tr * z
    };
    c = {
      x: -Ta / 2 * z,
      y: -Tr * z
    };
    t = getTriangle({
      x: x,
      y: y
    }, a, b, c);
    return tr = makeTriangle(t[0], t[1], t[2]);
  };

  bg.mousedown(function(e) {
    var x, y;
    window.startSplit = true;
    window.newTriangles = [];
    e.preventDefault();
    x = e.pageX;
    y = e.pageY;
    return pointToTriangle(x, y);
  });

  bg.mouseup(mouseUp);

  $("#saveButton").on("click", function() {
    var a, blob, svgString;
    a = this;
    svgString = '<svg style="overflow: hidden; position: relative;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="4096" version="1.1" height="4096">' + $('svg').html() + '</svg>';
    a.download = 'mySvg.svg';
    a.type = 'image/svg+xml';
    blob = new Blob([svgString], {
      "type": "image/svg+xml"
    });
    return a.href = (window.URL || webkitURL).createObjectURL(blob);
  });

  alpha = 0.9;

  toggleAlpha = function() {
    if (parseFloat($("svg").css("opacity")) < 1.0) {
      return $("svg").css("opacity", "1");
    } else {
      return $("svg").css("opacity", "0.9");
    }
  };

  toggleStroke = function() {
    window.stroked = !window.stroked;
    if (window.stroked) {
      return $("svg path").attr("stroke", window.strokeO);
    } else {
      return $("svg path").attr("stroke", "none");
    }
  };

  $("#alphaButton").on("click", toggleAlpha);

  $("#strokeButton").on("click", toggleStroke);

  $(window).keyup(function(e) {
    if (e.keyCode === 65) {
      toggleAlpha();
    }
    if (e.keyCode === 83) {
      return toggleStroke();
    }
  });

  $('body').on('contextmenu', function(e) {
    return false;
  });

}).call(this);
